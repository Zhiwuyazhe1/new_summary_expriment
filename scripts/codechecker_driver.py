"""Run CodeChecker analysis (wrapper).

This script builds and runs a CodeChecker `analyze` command configured to use
the clang static analyzer (clangsa). It's intended to be called from
`main_script.py` or used standalone from the command line.

Example command constructed by this script:
  CodeChecker analyze --analyzers clangsa \
	--saargs "<clangsa_cfg_string>" --ctu \
	--capture-analysis-output compile_commands.json \
	-o <reports_dir>

The implementation exposes a `run_codechecker` function that returns the
subprocess.CompletedProcess result and raises subprocess.CalledProcessError on
non-zero exit (unless called with check=False).
"""

from __future__ import annotations

import argparse
import os
import shlex
import subprocess
import sys
import tempfile
from typing import List, Optional



def run_codechecker(
	saargs: Optional[str],
	output_dir: str,
	compile_commands: str,
	ctu: bool = True,
	codechecker_bin: str = "CodeChecker",
	extra_args: Optional[List[str]] = None,
	cwd: Optional[str] = None,
	timeout: Optional[int] = None,
	dry_run: bool = False,
	verbose: bool = False,
	check: bool = True,
) -> subprocess.CompletedProcess:
	"""Build and run the CodeChecker analyze command.

	Args:
		saargs: The clang static analyzer config string (passed to --saargs).
		output_dir: Directory where CodeChecker will write the report outputs.
		compile_commands: Path for the compile_commands.json capture output.
		ctu: Whether to enable CTU (cross translation unit) analysis.
		codechecker_bin: Executable name or path for CodeChecker.
		extra_args: Additional command-line tokens to append.
		cwd: Working directory to run the command in.
		timeout: Timeout in seconds for the subprocess.
		dry_run: If True, only print the command instead of executing it.
		verbose: If True, print stdout/stderr on completion.
		check: If True, raise CalledProcessError on non-zero exit.

	Returns:
		subprocess.CompletedProcess from subprocess.run

	Raises:
		subprocess.CalledProcessError: if check is True and process exits non-zero.
	"""

	if extra_args is None:
		extra_args = []

	# Ensure output directory exists
	os.makedirs(output_dir, exist_ok=True)

	cmd: List[str] = [codechecker_bin, "analyze", "--analyzers", "clangsa"]

	# saargs may be None (no extra analyzer args) or a path/string accepted by
	# CodeChecker's --saargs option. If provided, pass it as a single token.
	if saargs:
		cmd.extend(["--saargs", saargs])

	if ctu:
		cmd.append("--ctu")

	cmd.extend(["--capture-analysis-output", compile_commands])

	cmd.extend(["-o", output_dir])

	if extra_args:
		cmd.extend(extra_args)

	# For logging and dry run, build a shell-friendly string for display
	cmd_display = " ".join(shlex.quote(c) for c in cmd)

	if dry_run:
		print("DRY RUN: would execute:\n", cmd_display)
		# Return a dummy CompletedProcess
		return subprocess.CompletedProcess(cmd, 0)

	# Execute
	try:
		proc = subprocess.run(
			cmd,
			cwd=cwd,
			stdout=subprocess.PIPE,
			stderr=subprocess.PIPE,
			text=True,
			timeout=timeout,
			check=check,
		)
	except subprocess.CalledProcessError:
		# Re-raise to let caller handle it; include stdout/stderr for debugging
		raise

	if verbose:
		if proc.stdout:
			print("[CodeChecker stdout]")
			print(proc.stdout)
		if proc.stderr:
			print("[CodeChecker stderr]")
			print(proc.stderr, file=sys.stderr)

	return proc


def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
	p = argparse.ArgumentParser(description="Run CodeChecker analyze for clangsa")

	# Path to compile_commands.json (produced by scripts/compile.py) and
	# output directory where CodeChecker will write analysis reports.
	# Use --compile-commands to pass the path to the compile_commands.json file
	# and --output-dir to specify the reports directory.
	p.add_argument(
		"--compile-commands",
		required=True,
		help="Path to compile_commands.json (generated by scripts/compile.py)",
	)

	p.add_argument(
		"--output-dir",
		required=True,
		help="Directory where CodeChecker will write the analysis reports",
	)

	p.add_argument(
		"--saargs-dir",
		default=None,
		help="Directory containing summaries to use when --use-summary is set",
	)

	p.add_argument("--no-ctu", action="store_true", help="Disable CTU analysis")
	p.add_argument(
		"--codechecker-bin",
		default="CodeChecker",
		help="CodeChecker executable name/path",
	)
	p.add_argument("--dry-run", action="store_true", help="Print the command but do not run it")
	p.add_argument("--verbose", action="store_true", help="Print stdout/stderr from CodeChecker")
	p.add_argument("--cwd", default=None, help="Working directory to run CodeChecker in")
	p.add_argument("--timeout", type=int, default=None, help="Timeout seconds for CodeChecker run")
	p.add_argument("--extra-args", nargs=argparse.REMAINDER, help="Extra args appended to the CodeChecker command")

	return p.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> int:
	args = parse_args(argv)
	try:
		# ALWAYS create a temporary saargs file. When --use-summary is set the
		# temporary saargs will point to the provided --summary-dir. When
		# --use-summary is NOT set the temporary saargs will point to
		# --null-summary-dir (a directory expected to contain no summaries).
		# This keeps the interface compatible with tools that require a
		# --saargs path while allowing a "no-summary" mode.
    
		# Call run_codechecker with the path (or None) for saargs
		run_codechecker(
			saargs=args.saargs_dir,
			output_dir=args.output_dir,
			compile_commands=args.compile_commands,
			ctu=not args.no_ctu,
			codechecker_bin=args.codechecker_bin,
			extra_args=args.extra_args,
			cwd=args.cwd,
			timeout=args.timeout,
			dry_run=args.dry_run,
			verbose=args.verbose,
		)
	except subprocess.CalledProcessError as exc:
		print("CodeChecker failed with return code:", exc.returncode, file=sys.stderr)
		if exc.stdout:
			print(exc.stdout)
		if exc.stderr:
			print(exc.stderr, file=sys.stderr)
		return exc.returncode
		

	return 0


if __name__ == "__main__":
	raise SystemExit(main())


